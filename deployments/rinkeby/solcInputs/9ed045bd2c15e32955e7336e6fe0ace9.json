{
  "language": "Solidity",
  "sources": {
    "contracts/Lottery.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.7;\r\n\r\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\r\nimport \"@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol\";\r\nimport \"@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol\";\r\nimport \"../interfaces/IPool.sol\";\r\nimport \"../interfaces/IWeth.sol\";\r\n\r\ncontract Lottery is VRFConsumerBaseV2 {\r\n    uint256 public constant entranceFeeUSD = 50;\r\n    uint256 public prizePool;\r\n\r\n    address payable[] public players;\r\n    address payable public recentWinner;\r\n    address public owner;\r\n    mapping(address => uint256) public playerDeposit;\r\n\r\n    enum LOTTERY_STATE {\r\n        OPEN,\r\n        CLOSE,\r\n        CALCULATING_WINNER,\r\n        WINNER_SELECTED\r\n    }\r\n    LOTTERY_STATE public lottery_state;\r\n\r\n    //****Random number params\r\n    //Our subscription ID.\r\n    uint64 subscriptionId;\r\n    bytes32 keyHash;\r\n    uint32 callbackGasLimit = 100000;\r\n    uint16 requestConfirmations = 3;\r\n    uint32 numWords = 1;\r\n    //*****\r\n\r\n    uint256[] public randomWords;\r\n\r\n    AggregatorV3Interface priceFeed;\r\n    VRFCoordinatorV2Interface vrfCoordinator;\r\n    IPool aavePool;\r\n    IWeth wethContract;\r\n\r\n    event NewPlayer(\r\n        uint256 date,\r\n        address player,\r\n        uint256 amount,\r\n        uint256 prizePool\r\n    );\r\n    event RandomRequestSent(uint256 date, uint256 requestId);\r\n    event RandomNumberReceived(\r\n        uint256 date,\r\n        uint256 randomNumber,\r\n        uint256 recentWinnerIndex,\r\n        address recentWinner\r\n    );\r\n    event EthReceived(uint256 date, address player, uint256 amount);\r\n    event MoneySentToWinner(uint256 date, address player, uint256 amount);\r\n\r\n    constructor(\r\n        address _priceFeedAddress,\r\n        address _vrfCoordinator,\r\n        address _aavePoolAddress,\r\n        address _wethContractAddress,\r\n        uint64 _subscriptionId,\r\n        bytes32 _keyHash\r\n    ) VRFConsumerBaseV2(_vrfCoordinator) {\r\n        lottery_state = LOTTERY_STATE.CLOSE;\r\n        owner = msg.sender;\r\n        priceFeed = AggregatorV3Interface(_priceFeedAddress);\r\n        vrfCoordinator = VRFCoordinatorV2Interface(_vrfCoordinator);\r\n        aavePool = IPool(_aavePoolAddress);\r\n        wethContract = IWeth(_wethContractAddress);\r\n        subscriptionId = _subscriptionId;\r\n        keyHash = _keyHash;\r\n    }\r\n\r\n    receive() external payable {\r\n        emit EthReceived(block.timestamp, msg.sender, msg.value);\r\n    }\r\n\r\n    fallback() external payable {}\r\n\r\n    //Show actual entrance fee in wei\r\n    function getEntranceFee() public view returns (uint256) {\r\n        //50*10^(8+18)/3000*10^8 to have answer in wei\r\n        (, int256 conversionRate, , , ) = priceFeed.latestRoundData();\r\n        return (entranceFeeUSD * 10**26) / uint256(conversionRate);\r\n    }\r\n\r\n    //Show number of participants\r\n    function getPlayersNumber() public view returns (uint256) {\r\n        return players.length;\r\n    }\r\n\r\n    function enter() public payable lotteryOpen {\r\n        require(msg.value >= getEntranceFee(), \"Not enough ETH to enter!\");\r\n        players.push(payable(msg.sender));\r\n        playerDeposit[msg.sender] += msg.value;\r\n        wethContract.deposit{value: msg.value}();\r\n        supplyFundsAave(msg.value);\r\n        prizePool += msg.value;\r\n        emit NewPlayer(block.timestamp, msg.sender, msg.value, prizePool);\r\n    }\r\n\r\n    //*****Admin functions *********************************\r\n    function startLottery() public lotteryClose onlyOwner {\r\n        for (uint256 i = 1; i < players.length; i++) {\r\n            address player = players[i];\r\n            playerDeposit[player] = 0;\r\n        }\r\n        players = new address payable[](0);\r\n        recentWinner = payable(address(0));\r\n        prizePool = 0;\r\n        lottery_state = LOTTERY_STATE.OPEN;\r\n    }\r\n\r\n    function endLottery() public lotteryOpen onlyOwner {\r\n        lottery_state = LOTTERY_STATE.CALCULATING_WINNER;\r\n        requestRandomWords();\r\n    }\r\n\r\n    function emrgStopLottery() public onlyOwner {\r\n        uint256 bigValue = 100 * 10**18;\r\n        withdrawAaveFunds(bigValue);\r\n        uint256 wethBalance = wethContract.balanceOf(address(this));\r\n        changeToEth(wethBalance);\r\n        payable(owner).transfer(address(this).balance);\r\n        lottery_state = LOTTERY_STATE.CLOSE;\r\n    }\r\n\r\n    function transferFundsToWinner() public lotteryWinnerSelected onlyOwner {\r\n        withdrawAaveFunds(prizePool);\r\n        changeToEth(prizePool);\r\n        recentWinner.transfer(prizePool);\r\n        lottery_state = LOTTERY_STATE.CLOSE;\r\n        emit MoneySentToWinner(block.timestamp, recentWinner, prizePool);\r\n    }\r\n\r\n    function checkAaveBalance()\r\n        public\r\n        view\r\n        onlyOwner\r\n        returns (uint256, uint256)\r\n    {\r\n        (\r\n            uint256 total_collateral_base,\r\n            uint256 total_debt_base,\r\n            ,\r\n            ,\r\n            ,\r\n\r\n        ) = aavePool.getUserAccountData(address(this));\r\n        return (total_collateral_base, total_debt_base);\r\n    }\r\n\r\n    function transferFundsToAdmin() public lotteryClose onlyOwner {\r\n        //Try big value\r\n        uint256 bigNumber = 10**18;\r\n        withdrawAaveFunds(bigNumber);\r\n        //Convert WETH to ETH\r\n        uint256 value = wethContract.balanceOf(address(this));\r\n        changeToEth(value);\r\n        //Send all Eth to owner\r\n        payable(owner).transfer(address(this).balance);\r\n    }\r\n\r\n    //***********Internal functions ********************\r\n    // Assumes the subscription is funded sufficiently.\r\n    function requestRandomWords() internal onlyOwner {\r\n        // Will revert if subscription is not set and funded.\r\n\r\n        uint256 requestId = vrfCoordinator.requestRandomWords(\r\n            keyHash,\r\n            subscriptionId,\r\n            requestConfirmations,\r\n            callbackGasLimit,\r\n            numWords\r\n        );\r\n        emit RandomRequestSent(block.timestamp, requestId);\r\n    }\r\n\r\n    function fulfillRandomWords(\r\n        uint256, /* requestId */\r\n        uint256[] memory _randomWords\r\n    ) internal override {\r\n        require(\r\n            lottery_state == LOTTERY_STATE.CALCULATING_WINNER,\r\n            \"Lottery is not in correct state\"\r\n        );\r\n        randomWords = _randomWords;\r\n        require(randomWords[0] > 0, \"Random number should be > 0\");\r\n        uint256 recentWinnerIndex = randomWords[0] % players.length;\r\n        recentWinner = players[recentWinnerIndex];\r\n        lottery_state = LOTTERY_STATE.WINNER_SELECTED;\r\n        emit RandomNumberReceived(\r\n            block.timestamp,\r\n            randomWords[0],\r\n            recentWinnerIndex,\r\n            recentWinner\r\n        );\r\n    }\r\n\r\n    function supplyFundsAave(uint256 amount) internal {\r\n        wethContract.approve(address(aavePool), amount);\r\n        aavePool.supply(address(wethContract), amount, address(this), 0);\r\n    }\r\n\r\n    //!!!!!!!!!!!!!!!\r\n    function withdrawAaveFunds(uint256 amount) public {\r\n        wethContract.approve(address(aavePool), amount);\r\n        aavePool.withdraw(address(wethContract), amount, address(this));\r\n    }\r\n\r\n    function changeToEth(uint256 _value) internal {\r\n        wethContract.approve(address(this), _value);\r\n        wethContract.withdraw(_value);\r\n    }\r\n\r\n    //********************Modifiers****************\r\n    modifier onlyOwner() {\r\n        require(\r\n            msg.sender == owner,\r\n            \"Only admin is allowed to do this operation\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier lotteryOpen() {\r\n        require(\r\n            lottery_state == LOTTERY_STATE.OPEN,\r\n            \"Lottery should be started\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier lotteryClose() {\r\n        require(\r\n            lottery_state == LOTTERY_STATE.CLOSE,\r\n            \"Lottery should be finished\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier lotteryCalculatingWinner() {\r\n        require(\r\n            lottery_state == LOTTERY_STATE.CALCULATING_WINNER,\r\n            \"Lottery should selecting winner\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier lotteryWinnerSelected() {\r\n        require(\r\n            lottery_state == LOTTERY_STATE.WINNER_SELECTED,\r\n            \"Lottery should select winner\"\r\n        );\r\n        _;\r\n    }\r\n}\r\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/VRFCoordinatorV2Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface VRFCoordinatorV2Interface {\n  /**\n   * @notice Get configuration relevant for making requests\n   * @return minimumRequestConfirmations global min for request confirmations\n   * @return maxGasLimit global max for request gas limit\n   * @return s_provingKeyHashes list of registered key hashes\n   */\n  function getRequestConfig()\n    external\n    view\n    returns (\n      uint16,\n      uint32,\n      bytes32[] memory\n    );\n\n  /**\n   * @notice Request a set of random words.\n   * @param keyHash - Corresponds to a particular oracle job which uses\n   * that key for generating the VRF proof. Different keyHash's have different gas price\n   * ceilings, so you can select a specific one to bound your maximum per request cost.\n   * @param subId  - The ID of the VRF subscription. Must be funded\n   * with the minimum subscription balance required for the selected keyHash.\n   * @param minimumRequestConfirmations - How many blocks you'd like the\n   * oracle to wait before responding to the request. See SECURITY CONSIDERATIONS\n   * for why you may want to request more. The acceptable range is\n   * [minimumRequestBlockConfirmations, 200].\n   * @param callbackGasLimit - How much gas you'd like to receive in your\n   * fulfillRandomWords callback. Note that gasleft() inside fulfillRandomWords\n   * may be slightly less than this amount because of gas used calling the function\n   * (argument decoding etc.), so you may need to request slightly more than you expect\n   * to have inside fulfillRandomWords. The acceptable range is\n   * [0, maxGasLimit]\n   * @param numWords - The number of uint256 random values you'd like to receive\n   * in your fulfillRandomWords callback. Note these numbers are expanded in a\n   * secure way by the VRFCoordinator from a single random value supplied by the oracle.\n   * @return requestId - A unique identifier of the request. Can be used to match\n   * a request to a response in fulfillRandomWords.\n   */\n  function requestRandomWords(\n    bytes32 keyHash,\n    uint64 subId,\n    uint16 minimumRequestConfirmations,\n    uint32 callbackGasLimit,\n    uint32 numWords\n  ) external returns (uint256 requestId);\n\n  /**\n   * @notice Create a VRF subscription.\n   * @return subId - A unique subscription id.\n   * @dev You can manage the consumer set dynamically with addConsumer/removeConsumer.\n   * @dev Note to fund the subscription, use transferAndCall. For example\n   * @dev  LINKTOKEN.transferAndCall(\n   * @dev    address(COORDINATOR),\n   * @dev    amount,\n   * @dev    abi.encode(subId));\n   */\n  function createSubscription() external returns (uint64 subId);\n\n  /**\n   * @notice Get a VRF subscription.\n   * @param subId - ID of the subscription\n   * @return balance - LINK balance of the subscription in juels.\n   * @return reqCount - number of requests for this subscription, determines fee tier.\n   * @return owner - owner of the subscription.\n   * @return consumers - list of consumer address which are able to use this subscription.\n   */\n  function getSubscription(uint64 subId)\n    external\n    view\n    returns (\n      uint96 balance,\n      uint64 reqCount,\n      address owner,\n      address[] memory consumers\n    );\n\n  /**\n   * @notice Request subscription owner transfer.\n   * @param subId - ID of the subscription\n   * @param newOwner - proposed new owner of the subscription\n   */\n  function requestSubscriptionOwnerTransfer(uint64 subId, address newOwner) external;\n\n  /**\n   * @notice Request subscription owner transfer.\n   * @param subId - ID of the subscription\n   * @dev will revert if original owner of subId has\n   * not requested that msg.sender become the new owner.\n   */\n  function acceptSubscriptionOwnerTransfer(uint64 subId) external;\n\n  /**\n   * @notice Add a consumer to a VRF subscription.\n   * @param subId - ID of the subscription\n   * @param consumer - New consumer which can use the subscription\n   */\n  function addConsumer(uint64 subId, address consumer) external;\n\n  /**\n   * @notice Remove a consumer from a VRF subscription.\n   * @param subId - ID of the subscription\n   * @param consumer - Consumer to remove from the subscription\n   */\n  function removeConsumer(uint64 subId, address consumer) external;\n\n  /**\n   * @notice Cancel a subscription\n   * @param subId - ID of the subscription\n   * @param to - Where to send the remaining LINK to\n   */\n  function cancelSubscription(uint64 subId, address to) external;\n\n  /*\n   * @notice Check to see if there exists a request commitment consumers\n   * for all consumers and keyhashes for a given sub.\n   * @param subId - ID of the subscription\n   * @return true if there exists at least one unfulfilled request for the subscription, false\n   * otherwise.\n   */\n  function pendingRequestExists(uint64 subId) external view returns (bool);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/VRFConsumerBaseV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/** ****************************************************************************\n * @notice Interface for contracts using VRF randomness\n * *****************************************************************************\n * @dev PURPOSE\n *\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\n * @dev to Vera the verifier in such a way that Vera can be sure he's not\n * @dev making his output up to suit himself. Reggie provides Vera a public key\n * @dev to which he knows the secret key. Each time Vera provides a seed to\n * @dev Reggie, he gives back a value which is computed completely\n * @dev deterministically from the seed and the secret key.\n *\n * @dev Reggie provides a proof by which Vera can verify that the output was\n * @dev correctly computed once Reggie tells it to her, but without that proof,\n * @dev the output is indistinguishable to her from a uniform random sample\n * @dev from the output space.\n *\n * @dev The purpose of this contract is to make it easy for unrelated contracts\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\n * @dev simple access to a verifiable source of randomness. It ensures 2 things:\n * @dev 1. The fulfillment came from the VRFCoordinator\n * @dev 2. The consumer contract implements fulfillRandomWords.\n * *****************************************************************************\n * @dev USAGE\n *\n * @dev Calling contracts must inherit from VRFConsumerBase, and can\n * @dev initialize VRFConsumerBase's attributes in their constructor as\n * @dev shown:\n *\n * @dev   contract VRFConsumer {\n * @dev     constructor(<other arguments>, address _vrfCoordinator, address _link)\n * @dev       VRFConsumerBase(_vrfCoordinator) public {\n * @dev         <initialization with other arguments goes here>\n * @dev       }\n * @dev   }\n *\n * @dev The oracle will have given you an ID for the VRF keypair they have\n * @dev committed to (let's call it keyHash). Create subscription, fund it\n * @dev and your consumer contract as a consumer of it (see VRFCoordinatorInterface\n * @dev subscription management functions).\n * @dev Call requestRandomWords(keyHash, subId, minimumRequestConfirmations,\n * @dev callbackGasLimit, numWords),\n * @dev see (VRFCoordinatorInterface for a description of the arguments).\n *\n * @dev Once the VRFCoordinator has received and validated the oracle's response\n * @dev to your request, it will call your contract's fulfillRandomWords method.\n *\n * @dev The randomness argument to fulfillRandomWords is a set of random words\n * @dev generated from your requestId and the blockHash of the request.\n *\n * @dev If your contract could have concurrent requests open, you can use the\n * @dev requestId returned from requestRandomWords to track which response is associated\n * @dev with which randomness request.\n * @dev See \"SECURITY CONSIDERATIONS\" for principles to keep in mind,\n * @dev if your contract could have multiple requests in flight simultaneously.\n *\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\n * @dev differ.\n *\n * *****************************************************************************\n * @dev SECURITY CONSIDERATIONS\n *\n * @dev A method with the ability to call your fulfillRandomness method directly\n * @dev could spoof a VRF response with any random value, so it's critical that\n * @dev it cannot be directly called by anything other than this base contract\n * @dev (specifically, by the VRFConsumerBase.rawFulfillRandomness method).\n *\n * @dev For your users to trust that your contract's random behavior is free\n * @dev from malicious interference, it's best if you can write it so that all\n * @dev behaviors implied by a VRF response are executed *during* your\n * @dev fulfillRandomness method. If your contract must store the response (or\n * @dev anything derived from it) and use it later, you must ensure that any\n * @dev user-significant behavior which depends on that stored value cannot be\n * @dev manipulated by a subsequent VRF request.\n *\n * @dev Similarly, both miners and the VRF oracle itself have some influence\n * @dev over the order in which VRF responses appear on the blockchain, so if\n * @dev your contract could have multiple VRF requests in flight simultaneously,\n * @dev you must ensure that the order in which the VRF responses arrive cannot\n * @dev be used to manipulate your contract's user-significant behavior.\n *\n * @dev Since the block hash of the block which contains the requestRandomness\n * @dev call is mixed into the input to the VRF *last*, a sufficiently powerful\n * @dev miner could, in principle, fork the blockchain to evict the block\n * @dev containing the request, forcing the request to be included in a\n * @dev different block with a different hash, and therefore a different input\n * @dev to the VRF. However, such an attack would incur a substantial economic\n * @dev cost. This cost scales with the number of blocks the VRF oracle waits\n * @dev until it calls responds to a request. It is for this reason that\n * @dev that you can signal to an oracle you'd like them to wait longer before\n * @dev responding to the request (however this is not enforced in the contract\n * @dev and so remains effective only in the case of unmodified oracle software).\n */\nabstract contract VRFConsumerBaseV2 {\n  error OnlyCoordinatorCanFulfill(address have, address want);\n  address private immutable vrfCoordinator;\n\n  /**\n   * @param _vrfCoordinator address of VRFCoordinator contract\n   */\n  constructor(address _vrfCoordinator) {\n    vrfCoordinator = _vrfCoordinator;\n  }\n\n  /**\n   * @notice fulfillRandomness handles the VRF response. Your contract must\n   * @notice implement it. See \"SECURITY CONSIDERATIONS\" above for important\n   * @notice principles to keep in mind when implementing your fulfillRandomness\n   * @notice method.\n   *\n   * @dev VRFConsumerBaseV2 expects its subcontracts to have a method with this\n   * @dev signature, and will call it once it has verified the proof\n   * @dev associated with the randomness. (It is triggered via a call to\n   * @dev rawFulfillRandomness, below.)\n   *\n   * @param requestId The Id initially returned by requestRandomness\n   * @param randomWords the VRF output expanded to the requested number of words\n   */\n  function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal virtual;\n\n  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF\n  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating\n  // the origin of the call\n  function rawFulfillRandomWords(uint256 requestId, uint256[] memory randomWords) external {\n    if (msg.sender != vrfCoordinator) {\n      revert OnlyCoordinatorCanFulfill(msg.sender, vrfCoordinator);\n    }\n    fulfillRandomWords(requestId, randomWords);\n  }\n}\n"
    },
    "interfaces/IPool.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\r\npragma solidity ^0.8.10;\r\n\r\nimport {IPoolAddressesProvider} from \"./IPoolAddressesProvider.sol\";\r\n\r\nimport {DataTypes} from \"../contracts/types/DataTypes.sol\";\r\n\r\n/**\r\n * @title IPool\r\n * @author Aave\r\n * @notice Defines the basic interface for an Aave Pool.\r\n **/\r\ninterface IPool {\r\n    /**\r\n     * @dev Emitted on mintUnbacked()\r\n     * @param reserve The address of the underlying asset of the reserve\r\n     * @param user The address initiating the supply\r\n     * @param onBehalfOf The beneficiary of the supplied assets, receiving the aTokens\r\n     * @param amount The amount of supplied assets\r\n     * @param referralCode The referral code used\r\n     **/\r\n    event MintUnbacked(\r\n        address indexed reserve,\r\n        address user,\r\n        address indexed onBehalfOf,\r\n        uint256 amount,\r\n        uint16 indexed referralCode\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted on backUnbacked()\r\n     * @param reserve The address of the underlying asset of the reserve\r\n     * @param backer The address paying for the backing\r\n     * @param amount The amount added as backing\r\n     * @param fee The amount paid in fees\r\n     **/\r\n    event BackUnbacked(\r\n        address indexed reserve,\r\n        address indexed backer,\r\n        uint256 amount,\r\n        uint256 fee\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted on supply()\r\n     * @param reserve The address of the underlying asset of the reserve\r\n     * @param user The address initiating the supply\r\n     * @param onBehalfOf The beneficiary of the supply, receiving the aTokens\r\n     * @param amount The amount supplied\r\n     * @param referralCode The referral code used\r\n     **/\r\n    event Supply(\r\n        address indexed reserve,\r\n        address user,\r\n        address indexed onBehalfOf,\r\n        uint256 amount,\r\n        uint16 indexed referralCode\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted on withdraw()\r\n     * @param reserve The address of the underlying asset being withdrawn\r\n     * @param user The address initiating the withdrawal, owner of aTokens\r\n     * @param to The address that will receive the underlying\r\n     * @param amount The amount to be withdrawn\r\n     **/\r\n    event Withdraw(\r\n        address indexed reserve,\r\n        address indexed user,\r\n        address indexed to,\r\n        uint256 amount\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted on borrow() and flashLoan() when debt needs to be opened\r\n     * @param reserve The address of the underlying asset being borrowed\r\n     * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just\r\n     * initiator of the transaction on flashLoan()\r\n     * @param onBehalfOf The address that will be getting the debt\r\n     * @param amount The amount borrowed out\r\n     * @param interestRateMode The rate mode: 1 for Stable, 2 for Variable\r\n     * @param borrowRate The numeric rate at which the user has borrowed, expressed in ray\r\n     * @param referralCode The referral code used\r\n     **/\r\n    event Borrow(\r\n        address indexed reserve,\r\n        address user,\r\n        address indexed onBehalfOf,\r\n        uint256 amount,\r\n        DataTypes.InterestRateMode interestRateMode,\r\n        uint256 borrowRate,\r\n        uint16 indexed referralCode\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted on repay()\r\n     * @param reserve The address of the underlying asset of the reserve\r\n     * @param user The beneficiary of the repayment, getting his debt reduced\r\n     * @param repayer The address of the user initiating the repay(), providing the funds\r\n     * @param amount The amount repaid\r\n     * @param useATokens True if the repayment is done using aTokens, `false` if done with underlying asset directly\r\n     **/\r\n    event Repay(\r\n        address indexed reserve,\r\n        address indexed user,\r\n        address indexed repayer,\r\n        uint256 amount,\r\n        bool useATokens\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted on swapBorrowRateMode()\r\n     * @param reserve The address of the underlying asset of the reserve\r\n     * @param user The address of the user swapping his rate mode\r\n     * @param interestRateMode The current interest rate mode of the position being swapped: 1 for Stable, 2 for Variable\r\n     **/\r\n    event SwapBorrowRateMode(\r\n        address indexed reserve,\r\n        address indexed user,\r\n        DataTypes.InterestRateMode interestRateMode\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted on borrow(), repay() and liquidationCall() when using isolated assets\r\n     * @param asset The address of the underlying asset of the reserve\r\n     * @param totalDebt The total isolation mode debt for the reserve\r\n     */\r\n    event IsolationModeTotalDebtUpdated(\r\n        address indexed asset,\r\n        uint256 totalDebt\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when the user selects a certain asset category for eMode\r\n     * @param user The address of the user\r\n     * @param categoryId The category id\r\n     **/\r\n    event UserEModeSet(address indexed user, uint8 categoryId);\r\n\r\n    /**\r\n     * @dev Emitted on setUserUseReserveAsCollateral()\r\n     * @param reserve The address of the underlying asset of the reserve\r\n     * @param user The address of the user enabling the usage as collateral\r\n     **/\r\n    event ReserveUsedAsCollateralEnabled(\r\n        address indexed reserve,\r\n        address indexed user\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted on setUserUseReserveAsCollateral()\r\n     * @param reserve The address of the underlying asset of the reserve\r\n     * @param user The address of the user enabling the usage as collateral\r\n     **/\r\n    event ReserveUsedAsCollateralDisabled(\r\n        address indexed reserve,\r\n        address indexed user\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted on rebalanceStableBorrowRate()\r\n     * @param reserve The address of the underlying asset of the reserve\r\n     * @param user The address of the user for which the rebalance has been executed\r\n     **/\r\n    event RebalanceStableBorrowRate(\r\n        address indexed reserve,\r\n        address indexed user\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted on flashLoan()\r\n     * @param target The address of the flash loan receiver contract\r\n     * @param initiator The address initiating the flash loan\r\n     * @param asset The address of the asset being flash borrowed\r\n     * @param amount The amount flash borrowed\r\n     * @param interestRateMode The flashloan mode: 0 for regular flashloan, 1 for Stable debt, 2 for Variable debt\r\n     * @param premium The fee flash borrowed\r\n     * @param referralCode The referral code used\r\n     **/\r\n    event FlashLoan(\r\n        address indexed target,\r\n        address initiator,\r\n        address indexed asset,\r\n        uint256 amount,\r\n        DataTypes.InterestRateMode interestRateMode,\r\n        uint256 premium,\r\n        uint16 indexed referralCode\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when a borrower is liquidated.\r\n     * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\r\n     * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\r\n     * @param user The address of the borrower getting liquidated\r\n     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\r\n     * @param liquidatedCollateralAmount The amount of collateral received by the liquidator\r\n     * @param liquidator The address of the liquidator\r\n     * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\r\n     * to receive the underlying collateral asset directly\r\n     **/\r\n    event LiquidationCall(\r\n        address indexed collateralAsset,\r\n        address indexed debtAsset,\r\n        address indexed user,\r\n        uint256 debtToCover,\r\n        uint256 liquidatedCollateralAmount,\r\n        address liquidator,\r\n        bool receiveAToken\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when the state of a reserve is updated.\r\n     * @param reserve The address of the underlying asset of the reserve\r\n     * @param liquidityRate The next liquidity rate\r\n     * @param stableBorrowRate The next stable borrow rate\r\n     * @param variableBorrowRate The next variable borrow rate\r\n     * @param liquidityIndex The next liquidity index\r\n     * @param variableBorrowIndex The next variable borrow index\r\n     **/\r\n    event ReserveDataUpdated(\r\n        address indexed reserve,\r\n        uint256 liquidityRate,\r\n        uint256 stableBorrowRate,\r\n        uint256 variableBorrowRate,\r\n        uint256 liquidityIndex,\r\n        uint256 variableBorrowIndex\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when the protocol treasury receives minted aTokens from the accrued interest.\r\n     * @param reserve The address of the reserve\r\n     * @param amountMinted The amount minted to the treasury\r\n     **/\r\n    event MintedToTreasury(address indexed reserve, uint256 amountMinted);\r\n\r\n    /**\r\n     * @dev Mints an `amount` of aTokens to the `onBehalfOf`\r\n     * @param asset The address of the underlying asset to mint\r\n     * @param amount The amount to mint\r\n     * @param onBehalfOf The address that will receive the aTokens\r\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\r\n     *   0 if the action is executed directly by the user, without any middle-man\r\n     **/\r\n    function mintUnbacked(\r\n        address asset,\r\n        uint256 amount,\r\n        address onBehalfOf,\r\n        uint16 referralCode\r\n    ) external;\r\n\r\n    /**\r\n     * @dev Back the current unbacked underlying with `amount` and pay `fee`.\r\n     * @param asset The address of the underlying asset to back\r\n     * @param amount The amount to back\r\n     * @param fee The amount paid in fees\r\n     **/\r\n    function backUnbacked(\r\n        address asset,\r\n        uint256 amount,\r\n        uint256 fee\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\r\n     * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\r\n     * @param asset The address of the underlying asset to supply\r\n     * @param amount The amount to be supplied\r\n     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\r\n     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\r\n     *   is a different wallet\r\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\r\n     *   0 if the action is executed directly by the user, without any middle-man\r\n     **/\r\n    function supply(\r\n        address asset,\r\n        uint256 amount,\r\n        address onBehalfOf,\r\n        uint16 referralCode\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Supply with transfer approval of asset to be supplied done via permit function\r\n     * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\r\n     * @param asset The address of the underlying asset to supply\r\n     * @param amount The amount to be supplied\r\n     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\r\n     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\r\n     *   is a different wallet\r\n     * @param deadline The deadline timestamp that the permit is valid\r\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\r\n     *   0 if the action is executed directly by the user, without any middle-man\r\n     * @param permitV The V parameter of ERC712 permit sig\r\n     * @param permitR The R parameter of ERC712 permit sig\r\n     * @param permitS The S parameter of ERC712 permit sig\r\n     **/\r\n    function supplyWithPermit(\r\n        address asset,\r\n        uint256 amount,\r\n        address onBehalfOf,\r\n        uint16 referralCode,\r\n        uint256 deadline,\r\n        uint8 permitV,\r\n        bytes32 permitR,\r\n        bytes32 permitS\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\r\n     * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\r\n     * @param asset The address of the underlying asset to withdraw\r\n     * @param amount The underlying amount to be withdrawn\r\n     *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\r\n     * @param to The address that will receive the underlying, same as msg.sender if the user\r\n     *   wants to receive it on his own wallet, or a different address if the beneficiary is a\r\n     *   different wallet\r\n     * @return The final amount withdrawn\r\n     **/\r\n    function withdraw(\r\n        address asset,\r\n        uint256 amount,\r\n        address to\r\n    ) external returns (uint256);\r\n\r\n    /**\r\n     * @notice Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\r\n     * already supplied enough collateral, or he was given enough allowance by a credit delegator on the\r\n     * corresponding debt token (StableDebtToken or VariableDebtToken)\r\n     * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\r\n     *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\r\n     * @param asset The address of the underlying asset to borrow\r\n     * @param amount The amount to be borrowed\r\n     * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\r\n     * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\r\n     *   0 if the action is executed directly by the user, without any middle-man\r\n     * @param onBehalfOf The address of the user who will receive the debt. Should be the address of the borrower itself\r\n     * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\r\n     * if he has been given credit delegation allowance\r\n     **/\r\n    function borrow(\r\n        address asset,\r\n        uint256 amount,\r\n        uint256 interestRateMode,\r\n        uint16 referralCode,\r\n        address onBehalfOf\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\r\n     * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\r\n     * @param asset The address of the borrowed underlying asset previously borrowed\r\n     * @param amount The amount to repay\r\n     * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\r\n     * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\r\n     * @param onBehalfOf The address of the user who will get his debt reduced/removed. Should be the address of the\r\n     * user calling the function if he wants to reduce/remove his own debt, or the address of any other\r\n     * other borrower whose debt should be removed\r\n     * @return The final amount repaid\r\n     **/\r\n    function repay(\r\n        address asset,\r\n        uint256 amount,\r\n        uint256 interestRateMode,\r\n        address onBehalfOf\r\n    ) external returns (uint256);\r\n\r\n    /**\r\n     * @notice Repay with transfer approval of asset to be repaid done via permit function\r\n     * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713\r\n     * @param asset The address of the borrowed underlying asset previously borrowed\r\n     * @param amount The amount to repay\r\n     * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\r\n     * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\r\n     * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\r\n     * user calling the function if he wants to reduce/remove his own debt, or the address of any other\r\n     * other borrower whose debt should be removed\r\n     * @param deadline The deadline timestamp that the permit is valid\r\n     * @param permitV The V parameter of ERC712 permit sig\r\n     * @param permitR The R parameter of ERC712 permit sig\r\n     * @param permitS The S parameter of ERC712 permit sig\r\n     * @return The final amount repaid\r\n     **/\r\n    function repayWithPermit(\r\n        address asset,\r\n        uint256 amount,\r\n        uint256 interestRateMode,\r\n        address onBehalfOf,\r\n        uint256 deadline,\r\n        uint8 permitV,\r\n        bytes32 permitR,\r\n        bytes32 permitS\r\n    ) external returns (uint256);\r\n\r\n    /**\r\n     * @notice Repays a borrowed `amount` on a specific reserve using the reserve aTokens, burning the\r\n     * equivalent debt tokens\r\n     * - E.g. User repays 100 USDC using 100 aUSDC, burning 100 variable/stable debt tokens\r\n     * @dev  Passing uint256.max as amount will clean up any residual aToken dust balance, if the user aToken\r\n     * balance is not enough to cover the whole debt\r\n     * @param asset The address of the borrowed underlying asset previously borrowed\r\n     * @param amount The amount to repay\r\n     * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\r\n     * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\r\n     * @return The final amount repaid\r\n     **/\r\n    function repayWithATokens(\r\n        address asset,\r\n        uint256 amount,\r\n        uint256 interestRateMode\r\n    ) external returns (uint256);\r\n\r\n    /**\r\n     * @notice Allows a borrower to swap his debt between stable and variable mode, or vice versa\r\n     * @param asset The address of the underlying asset borrowed\r\n     * @param interestRateMode The current interest rate mode of the position being swapped: 1 for Stable, 2 for Variable\r\n     **/\r\n    function swapBorrowRateMode(address asset, uint256 interestRateMode)\r\n        external;\r\n\r\n    /**\r\n     * @notice Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.\r\n     * - Users can be rebalanced if the following conditions are satisfied:\r\n     *     1. Usage ratio is above 95%\r\n     *     2. the current supply APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too\r\n     *        much has been borrowed at a stable rate and suppliers are not earning enough\r\n     * @param asset The address of the underlying asset borrowed\r\n     * @param user The address of the user to be rebalanced\r\n     **/\r\n    function rebalanceStableBorrowRate(address asset, address user) external;\r\n\r\n    /**\r\n     * @notice Allows suppliers to enable/disable a specific supplied asset as collateral\r\n     * @param asset The address of the underlying asset supplied\r\n     * @param useAsCollateral True if the user wants to use the supply as collateral, false otherwise\r\n     **/\r\n    function setUserUseReserveAsCollateral(address asset, bool useAsCollateral)\r\n        external;\r\n\r\n    /**\r\n     * @notice Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1\r\n     * - The caller (liquidator) covers `debtToCover` amount of debt of the user getting liquidated, and receives\r\n     *   a proportionally amount of the `collateralAsset` plus a bonus to cover market risk\r\n     * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation\r\n     * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation\r\n     * @param user The address of the borrower getting liquidated\r\n     * @param debtToCover The debt amount of borrowed `asset` the liquidator wants to cover\r\n     * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, `false` if he wants\r\n     * to receive the underlying collateral asset directly\r\n     **/\r\n    function liquidationCall(\r\n        address collateralAsset,\r\n        address debtAsset,\r\n        address user,\r\n        uint256 debtToCover,\r\n        bool receiveAToken\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\r\n     * as long as the amount taken plus a fee is returned.\r\n     * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\r\n     * into consideration. For further details please visit https://developers.aave.com\r\n     * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanReceiver interface\r\n     * @param assets The addresses of the assets being flash-borrowed\r\n     * @param amounts The amounts of the assets being flash-borrowed\r\n     * @param interestRateModes Types of the debt to open if the flash loan is not returned:\r\n     *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver\r\n     *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\r\n     *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the `onBehalfOf` address\r\n     * @param onBehalfOf The address  that will receive the debt in the case of using on `modes` 1 or 2\r\n     * @param params Variadic packed params to pass to the receiver as extra information\r\n     * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\r\n     *   0 if the action is executed directly by the user, without any middle-man\r\n     **/\r\n    function flashLoan(\r\n        address receiverAddress,\r\n        address[] calldata assets,\r\n        uint256[] calldata amounts,\r\n        uint256[] calldata interestRateModes,\r\n        address onBehalfOf,\r\n        bytes calldata params,\r\n        uint16 referralCode\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,\r\n     * as long as the amount taken plus a fee is returned.\r\n     * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept\r\n     * into consideration. For further details please visit https://developers.aave.com\r\n     * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanSimpleReceiver interface\r\n     * @param asset The address of the asset being flash-borrowed\r\n     * @param amount The amount of the asset being flash-borrowed\r\n     * @param params Variadic packed params to pass to the receiver as extra information\r\n     * @param referralCode The code used to register the integrator originating the operation, for potential rewards.\r\n     *   0 if the action is executed directly by the user, without any middle-man\r\n     **/\r\n    function flashLoanSimple(\r\n        address receiverAddress,\r\n        address asset,\r\n        uint256 amount,\r\n        bytes calldata params,\r\n        uint16 referralCode\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Returns the user account data across all the reserves\r\n     * @param user The address of the user\r\n     * @return totalCollateralBase The total collateral of the user in the base currency used by the price feed\r\n     * @return totalDebtBase The total debt of the user in the base currency used by the price feed\r\n     * @return availableBorrowsBase The borrowing power left of the user in the base currency used by the price feed\r\n     * @return currentLiquidationThreshold The liquidation threshold of the user\r\n     * @return ltv The loan to value of The user\r\n     * @return healthFactor The current health factor of the user\r\n     **/\r\n    function getUserAccountData(address user)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 totalCollateralBase,\r\n            uint256 totalDebtBase,\r\n            uint256 availableBorrowsBase,\r\n            uint256 currentLiquidationThreshold,\r\n            uint256 ltv,\r\n            uint256 healthFactor\r\n        );\r\n\r\n    /**\r\n     * @notice Initializes a reserve, activating it, assigning an aToken and debt tokens and an\r\n     * interest rate strategy\r\n     * @dev Only callable by the PoolConfigurator contract\r\n     * @param asset The address of the underlying asset of the reserve\r\n     * @param aTokenAddress The address of the aToken that will be assigned to the reserve\r\n     * @param stableDebtAddress The address of the StableDebtToken that will be assigned to the reserve\r\n     * @param variableDebtAddress The address of the VariableDebtToken that will be assigned to the reserve\r\n     * @param interestRateStrategyAddress The address of the interest rate strategy contract\r\n     **/\r\n    function initReserve(\r\n        address asset,\r\n        address aTokenAddress,\r\n        address stableDebtAddress,\r\n        address variableDebtAddress,\r\n        address interestRateStrategyAddress\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Drop a reserve\r\n     * @dev Only callable by the PoolConfigurator contract\r\n     * @param asset The address of the underlying asset of the reserve\r\n     **/\r\n    function dropReserve(address asset) external;\r\n\r\n    /**\r\n     * @notice Updates the address of the interest rate strategy contract\r\n     * @dev Only callable by the PoolConfigurator contract\r\n     * @param asset The address of the underlying asset of the reserve\r\n     * @param rateStrategyAddress The address of the interest rate strategy contract\r\n     **/\r\n    function setReserveInterestRateStrategyAddress(\r\n        address asset,\r\n        address rateStrategyAddress\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Sets the configuration bitmap of the reserve as a whole\r\n     * @dev Only callable by the PoolConfigurator contract\r\n     * @param asset The address of the underlying asset of the reserve\r\n     * @param configuration The new configuration bitmap\r\n     **/\r\n    function setConfiguration(\r\n        address asset,\r\n        DataTypes.ReserveConfigurationMap calldata configuration\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Returns the configuration of the reserve\r\n     * @param asset The address of the underlying asset of the reserve\r\n     * @return The configuration of the reserve\r\n     **/\r\n    function getConfiguration(address asset)\r\n        external\r\n        view\r\n        returns (DataTypes.ReserveConfigurationMap memory);\r\n\r\n    /**\r\n     * @notice Returns the configuration of the user across all the reserves\r\n     * @param user The user address\r\n     * @return The configuration of the user\r\n     **/\r\n    function getUserConfiguration(address user)\r\n        external\r\n        view\r\n        returns (DataTypes.UserConfigurationMap memory);\r\n\r\n    /**\r\n     * @notice Returns the normalized income normalized income of the reserve\r\n     * @param asset The address of the underlying asset of the reserve\r\n     * @return The reserve's normalized income\r\n     */\r\n    function getReserveNormalizedIncome(address asset)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @notice Returns the normalized variable debt per unit of asset\r\n     * @param asset The address of the underlying asset of the reserve\r\n     * @return The reserve normalized variable debt\r\n     */\r\n    function getReserveNormalizedVariableDebt(address asset)\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @notice Returns the state and configuration of the reserve\r\n     * @param asset The address of the underlying asset of the reserve\r\n     * @return The state and configuration data of the reserve\r\n     **/\r\n    function getReserveData(address asset)\r\n        external\r\n        view\r\n        returns (DataTypes.ReserveData memory);\r\n\r\n    /**\r\n     * @notice Validates and finalizes an aToken transfer\r\n     * @dev Only callable by the overlying aToken of the `asset`\r\n     * @param asset The address of the underlying asset of the aToken\r\n     * @param from The user from which the aTokens are transferred\r\n     * @param to The user receiving the aTokens\r\n     * @param amount The amount being transferred/withdrawn\r\n     * @param balanceFromBefore The aToken balance of the `from` user before the transfer\r\n     * @param balanceToBefore The aToken balance of the `to` user before the transfer\r\n     */\r\n    function finalizeTransfer(\r\n        address asset,\r\n        address from,\r\n        address to,\r\n        uint256 amount,\r\n        uint256 balanceFromBefore,\r\n        uint256 balanceToBefore\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Returns the list of the underlying assets of all the initialized reserves\r\n     * @dev It does not include dropped reserves\r\n     * @return The addresses of the underlying assets of the initialized reserves\r\n     **/\r\n    function getReservesList() external view returns (address[] memory);\r\n\r\n    /**\r\n     * @notice Returns the address of the underlying asset of a reserve by the reserve id as stored in the DataTypes.ReserveData struct\r\n     * @param id The id of the reserve as stored in the DataTypes.ReserveData struct\r\n     * @return The address of the reserve associated with id\r\n     **/\r\n    function getReserveAddressById(uint16 id) external view returns (address);\r\n\r\n    /**\r\n     * @notice Returns the PoolAddressesProvider connected to this contract\r\n     * @return The address of the PoolAddressesProvider\r\n     **/\r\n    function ADDRESSES_PROVIDER()\r\n        external\r\n        view\r\n        returns (IPoolAddressesProvider);\r\n\r\n    /**\r\n     * @notice Updates the protocol fee on the bridging\r\n     * @param bridgeProtocolFee The part of the premium sent to the protocol treasury\r\n     */\r\n    function updateBridgeProtocolFee(uint256 bridgeProtocolFee) external;\r\n\r\n    /**\r\n     * @notice Updates flash loan premiums. Flash loan premium consists of two parts:\r\n     * - A part is sent to aToken holders as extra, one time accumulated interest\r\n     * - A part is collected by the protocol treasury\r\n     * @dev The total premium is calculated on the total borrowed amount\r\n     * @dev The premium to protocol is calculated on the total premium, being a percentage of `flashLoanPremiumTotal`\r\n     * @dev Only callable by the PoolConfigurator contract\r\n     * @param flashLoanPremiumTotal The total premium, expressed in bps\r\n     * @param flashLoanPremiumToProtocol The part of the premium sent to the protocol treasury, expressed in bps\r\n     */\r\n    function updateFlashloanPremiums(\r\n        uint128 flashLoanPremiumTotal,\r\n        uint128 flashLoanPremiumToProtocol\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Configures a new category for the eMode.\r\n     * @dev In eMode, the protocol allows very high borrowing power to borrow assets of the same category.\r\n     * The category 0 is reserved as it's the default for volatile assets\r\n     * @param id The id of the category\r\n     * @param config The configuration of the category\r\n     */\r\n    function configureEModeCategory(\r\n        uint8 id,\r\n        DataTypes.EModeCategory memory config\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Returns the data of an eMode category\r\n     * @param id The id of the category\r\n     * @return The configuration data of the category\r\n     */\r\n    function getEModeCategoryData(uint8 id)\r\n        external\r\n        view\r\n        returns (DataTypes.EModeCategory memory);\r\n\r\n    /**\r\n     * @notice Allows a user to use the protocol in eMode\r\n     * @param categoryId The id of the category\r\n     */\r\n    function setUserEMode(uint8 categoryId) external;\r\n\r\n    /**\r\n     * @notice Returns the eMode the user is using\r\n     * @param user The address of the user\r\n     * @return The eMode id\r\n     */\r\n    function getUserEMode(address user) external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Resets the isolation mode total debt of the given asset to zero\r\n     * @dev It requires the given asset has zero debt ceiling\r\n     * @param asset The address of the underlying asset to reset the isolationModeTotalDebt\r\n     */\r\n    function resetIsolationModeTotalDebt(address asset) external;\r\n\r\n    /**\r\n     * @notice Returns the percentage of available liquidity that can be borrowed at once at stable rate\r\n     * @return The percentage of available liquidity to borrow, expressed in bps\r\n     */\r\n    function MAX_STABLE_RATE_BORROW_SIZE_PERCENT()\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    /**\r\n     * @notice Returns the total fee on flash loans\r\n     * @return The total fee on flashloans\r\n     */\r\n    function FLASHLOAN_PREMIUM_TOTAL() external view returns (uint128);\r\n\r\n    /**\r\n     * @notice Returns the part of the bridge fees sent to protocol\r\n     * @return The bridge fee sent to the protocol treasury\r\n     */\r\n    function BRIDGE_PROTOCOL_FEE() external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Returns the part of the flashloan fees sent to protocol\r\n     * @return The flashloan fee sent to the protocol treasury\r\n     */\r\n    function FLASHLOAN_PREMIUM_TO_PROTOCOL() external view returns (uint128);\r\n\r\n    /**\r\n     * @notice Returns the maximum number of reserves supported to be listed in this Pool\r\n     * @return The maximum number of reserves supported\r\n     */\r\n    function MAX_NUMBER_RESERVES() external view returns (uint16);\r\n\r\n    /**\r\n     * @notice Mints the assets accrued through the reserve factor to the treasury in the form of aTokens\r\n     * @param assets The list of reserves for which the minting needs to be executed\r\n     **/\r\n    function mintToTreasury(address[] calldata assets) external;\r\n\r\n    /**\r\n     * @notice Rescue and transfer tokens locked in this contract\r\n     * @param token The address of the token\r\n     * @param to The address of the recipient\r\n     * @param amount The amount of token to transfer\r\n     */\r\n    function rescueTokens(\r\n        address token,\r\n        address to,\r\n        uint256 amount\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Supplies an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\r\n     * - E.g. User supplies 100 USDC and gets in return 100 aUSDC\r\n     * @dev Deprecated: Use the `supply` function instead\r\n     * @param asset The address of the underlying asset to supply\r\n     * @param amount The amount to be supplied\r\n     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\r\n     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\r\n     *   is a different wallet\r\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\r\n     *   0 if the action is executed directly by the user, without any middle-man\r\n     **/\r\n    function deposit(\r\n        address asset,\r\n        uint256 amount,\r\n        address onBehalfOf,\r\n        uint16 referralCode\r\n    ) external;\r\n}\r\n"
    },
    "interfaces/IWeth.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.10;\r\n\r\ninterface IWeth {\r\n    function allowance(address owner, address spender)\r\n        external\r\n        view\r\n        returns (uint256 remaining);\r\n\r\n    function approve(address spender, uint256 value)\r\n        external\r\n        returns (bool success);\r\n\r\n    function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n    function decimals() external view returns (uint8 decimalPlaces);\r\n\r\n    function name() external view returns (string memory tokenName);\r\n\r\n    function symbol() external view returns (string memory tokenSymbol);\r\n\r\n    function totalSupply() external view returns (uint256 totalTokensIssued);\r\n\r\n    function transfer(address to, uint256 value)\r\n        external\r\n        returns (bool success);\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) external returns (bool success);\r\n\r\n    function deposit() external payable;\r\n\r\n    function withdraw(uint256 wad) external;\r\n}\r\n"
    },
    "interfaces/IPoolAddressesProvider.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0\r\npragma solidity ^0.8.10;\r\n\r\n/**\r\n * @title IPoolAddressesProvider\r\n * @author Aave\r\n * @notice Defines the basic interface for a Pool Addresses Provider.\r\n **/\r\ninterface IPoolAddressesProvider {\r\n    /**\r\n     * @dev Emitted when the market identifier is updated.\r\n     * @param oldMarketId The old id of the market\r\n     * @param newMarketId The new id of the market\r\n     */\r\n    event MarketIdSet(string indexed oldMarketId, string indexed newMarketId);\r\n\r\n    /**\r\n     * @dev Emitted when the pool is updated.\r\n     * @param oldAddress The old address of the Pool\r\n     * @param newAddress The new address of the Pool\r\n     */\r\n    event PoolUpdated(address indexed oldAddress, address indexed newAddress);\r\n\r\n    /**\r\n     * @dev Emitted when the pool configurator is updated.\r\n     * @param oldAddress The old address of the PoolConfigurator\r\n     * @param newAddress The new address of the PoolConfigurator\r\n     */\r\n    event PoolConfiguratorUpdated(\r\n        address indexed oldAddress,\r\n        address indexed newAddress\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when the price oracle is updated.\r\n     * @param oldAddress The old address of the PriceOracle\r\n     * @param newAddress The new address of the PriceOracle\r\n     */\r\n    event PriceOracleUpdated(\r\n        address indexed oldAddress,\r\n        address indexed newAddress\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when the ACL manager is updated.\r\n     * @param oldAddress The old address of the ACLManager\r\n     * @param newAddress The new address of the ACLManager\r\n     */\r\n    event ACLManagerUpdated(\r\n        address indexed oldAddress,\r\n        address indexed newAddress\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when the ACL admin is updated.\r\n     * @param oldAddress The old address of the ACLAdmin\r\n     * @param newAddress The new address of the ACLAdmin\r\n     */\r\n    event ACLAdminUpdated(\r\n        address indexed oldAddress,\r\n        address indexed newAddress\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when the price oracle sentinel is updated.\r\n     * @param oldAddress The old address of the PriceOracleSentinel\r\n     * @param newAddress The new address of the PriceOracleSentinel\r\n     */\r\n    event PriceOracleSentinelUpdated(\r\n        address indexed oldAddress,\r\n        address indexed newAddress\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when the pool data provider is updated.\r\n     * @param oldAddress The old address of the PoolDataProvider\r\n     * @param newAddress The new address of the PoolDataProvider\r\n     */\r\n    event PoolDataProviderUpdated(\r\n        address indexed oldAddress,\r\n        address indexed newAddress\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when a new proxy is created.\r\n     * @param id The identifier of the proxy\r\n     * @param proxyAddress The address of the created proxy contract\r\n     * @param implementationAddress The address of the implementation contract\r\n     */\r\n    event ProxyCreated(\r\n        bytes32 indexed id,\r\n        address indexed proxyAddress,\r\n        address indexed implementationAddress\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when a new non-proxied contract address is registered.\r\n     * @param id The identifier of the contract\r\n     * @param oldAddress The address of the old contract\r\n     * @param newAddress The address of the new contract\r\n     */\r\n    event AddressSet(\r\n        bytes32 indexed id,\r\n        address indexed oldAddress,\r\n        address indexed newAddress\r\n    );\r\n\r\n    /**\r\n     * @dev Emitted when the implementation of the proxy registered with id is updated\r\n     * @param id The identifier of the contract\r\n     * @param proxyAddress The address of the proxy contract\r\n     * @param oldImplementationAddress The address of the old implementation contract\r\n     * @param newImplementationAddress The address of the new implementation contract\r\n     */\r\n    event AddressSetAsProxy(\r\n        bytes32 indexed id,\r\n        address indexed proxyAddress,\r\n        address oldImplementationAddress,\r\n        address indexed newImplementationAddress\r\n    );\r\n\r\n    /**\r\n     * @notice Returns the id of the Aave market to which this contract points to.\r\n     * @return The market id\r\n     **/\r\n    function getMarketId() external view returns (string memory);\r\n\r\n    /**\r\n     * @notice Associates an id with a specific PoolAddressesProvider.\r\n     * @dev This can be used to create an onchain registry of PoolAddressesProviders to\r\n     * identify and validate multiple Aave markets.\r\n     * @param newMarketId The market id\r\n     */\r\n    function setMarketId(string calldata newMarketId) external;\r\n\r\n    /**\r\n     * @notice Returns an address by its identifier.\r\n     * @dev The returned address might be an EOA or a contract, potentially proxied\r\n     * @dev It returns ZERO if there is no registered address with the given id\r\n     * @param id The id\r\n     * @return The address of the registered for the specified id\r\n     */\r\n    function getAddress(bytes32 id) external view returns (address);\r\n\r\n    /**\r\n     * @notice General function to update the implementation of a proxy registered with\r\n     * certain `id`. If there is no proxy registered, it will instantiate one and\r\n     * set as implementation the `newImplementationAddress`.\r\n     * @dev IMPORTANT Use this function carefully, only for ids that don't have an explicit\r\n     * setter function, in order to avoid unexpected consequences\r\n     * @param id The id\r\n     * @param newImplementationAddress The address of the new implementation\r\n     */\r\n    function setAddressAsProxy(bytes32 id, address newImplementationAddress)\r\n        external;\r\n\r\n    /**\r\n     * @notice Sets an address for an id replacing the address saved in the addresses map.\r\n     * @dev IMPORTANT Use this function carefully, as it will do a hard replacement\r\n     * @param id The id\r\n     * @param newAddress The address to set\r\n     */\r\n    function setAddress(bytes32 id, address newAddress) external;\r\n\r\n    /**\r\n     * @notice Returns the address of the Pool proxy.\r\n     * @return The Pool proxy address\r\n     **/\r\n    function getPool() external view returns (address);\r\n\r\n    /**\r\n     * @notice Updates the implementation of the Pool, or creates a proxy\r\n     * setting the new `pool` implementation when the function is called for the first time.\r\n     * @param newPoolImpl The new Pool implementation\r\n     **/\r\n    function setPoolImpl(address newPoolImpl) external;\r\n\r\n    /**\r\n     * @notice Returns the address of the PoolConfigurator proxy.\r\n     * @return The PoolConfigurator proxy address\r\n     **/\r\n    function getPoolConfigurator() external view returns (address);\r\n\r\n    /**\r\n     * @notice Updates the implementation of the PoolConfigurator, or creates a proxy\r\n     * setting the new `PoolConfigurator` implementation when the function is called for the first time.\r\n     * @param newPoolConfiguratorImpl The new PoolConfigurator implementation\r\n     **/\r\n    function setPoolConfiguratorImpl(address newPoolConfiguratorImpl) external;\r\n\r\n    /**\r\n     * @notice Returns the address of the price oracle.\r\n     * @return The address of the PriceOracle\r\n     */\r\n    function getPriceOracle() external view returns (address);\r\n\r\n    /**\r\n     * @notice Updates the address of the price oracle.\r\n     * @param newPriceOracle The address of the new PriceOracle\r\n     */\r\n    function setPriceOracle(address newPriceOracle) external;\r\n\r\n    /**\r\n     * @notice Returns the address of the ACL manager.\r\n     * @return The address of the ACLManager\r\n     */\r\n    function getACLManager() external view returns (address);\r\n\r\n    /**\r\n     * @notice Updates the address of the ACL manager.\r\n     * @param newAclManager The address of the new ACLManager\r\n     **/\r\n    function setACLManager(address newAclManager) external;\r\n\r\n    /**\r\n     * @notice Returns the address of the ACL admin.\r\n     * @return The address of the ACL admin\r\n     */\r\n    function getACLAdmin() external view returns (address);\r\n\r\n    /**\r\n     * @notice Updates the address of the ACL admin.\r\n     * @param newAclAdmin The address of the new ACL admin\r\n     */\r\n    function setACLAdmin(address newAclAdmin) external;\r\n\r\n    /**\r\n     * @notice Returns the address of the price oracle sentinel.\r\n     * @return The address of the PriceOracleSentinel\r\n     */\r\n    function getPriceOracleSentinel() external view returns (address);\r\n\r\n    /**\r\n     * @notice Updates the address of the price oracle sentinel.\r\n     * @param newPriceOracleSentinel The address of the new PriceOracleSentinel\r\n     **/\r\n    function setPriceOracleSentinel(address newPriceOracleSentinel) external;\r\n\r\n    /**\r\n     * @notice Returns the address of the data provider.\r\n     * @return The address of the DataProvider\r\n     */\r\n    function getPoolDataProvider() external view returns (address);\r\n\r\n    /**\r\n     * @notice Updates the address of the data provider.\r\n     * @param newDataProvider The address of the new DataProvider\r\n     **/\r\n    function setPoolDataProvider(address newDataProvider) external;\r\n}\r\n"
    },
    "contracts/types/DataTypes.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity ^0.8.10;\r\n\r\nlibrary DataTypes {\r\n    struct ReserveData {\r\n        //stores the reserve configuration\r\n        ReserveConfigurationMap configuration;\r\n        //the liquidity index. Expressed in ray\r\n        uint128 liquidityIndex;\r\n        //the current supply rate. Expressed in ray\r\n        uint128 currentLiquidityRate;\r\n        //variable borrow index. Expressed in ray\r\n        uint128 variableBorrowIndex;\r\n        //the current variable borrow rate. Expressed in ray\r\n        uint128 currentVariableBorrowRate;\r\n        //the current stable borrow rate. Expressed in ray\r\n        uint128 currentStableBorrowRate;\r\n        //timestamp of last update\r\n        uint40 lastUpdateTimestamp;\r\n        //the id of the reserve. Represents the position in the list of the active reserves\r\n        uint16 id;\r\n        //aToken address\r\n        address aTokenAddress;\r\n        //stableDebtToken address\r\n        address stableDebtTokenAddress;\r\n        //variableDebtToken address\r\n        address variableDebtTokenAddress;\r\n        //address of the interest rate strategy\r\n        address interestRateStrategyAddress;\r\n        //the current treasury balance, scaled\r\n        uint128 accruedToTreasury;\r\n        //the outstanding unbacked aTokens minted through the bridging feature\r\n        uint128 unbacked;\r\n        //the outstanding debt borrowed against this asset in isolation mode\r\n        uint128 isolationModeTotalDebt;\r\n    }\r\n\r\n    struct ReserveConfigurationMap {\r\n        //bit 0-15: LTV\r\n        //bit 16-31: Liq. threshold\r\n        //bit 32-47: Liq. bonus\r\n        //bit 48-55: Decimals\r\n        //bit 56: reserve is active\r\n        //bit 57: reserve is frozen\r\n        //bit 58: borrowing is enabled\r\n        //bit 59: stable rate borrowing enabled\r\n        //bit 60: asset is paused\r\n        //bit 61: borrowing in isolation mode is enabled\r\n        //bit 62-63: reserved\r\n        //bit 64-79: reserve factor\r\n        //bit 80-115 borrow cap in whole tokens, borrowCap == 0 => no cap\r\n        //bit 116-151 supply cap in whole tokens, supplyCap == 0 => no cap\r\n        //bit 152-167 liquidation protocol fee\r\n        //bit 168-175 eMode category\r\n        //bit 176-211 unbacked mint cap in whole tokens, unbackedMintCap == 0 => minting disabled\r\n        //bit 212-251 debt ceiling for isolation mode with (ReserveConfiguration::DEBT_CEILING_DECIMALS) decimals\r\n        //bit 252-255 unused\r\n\r\n        uint256 data;\r\n    }\r\n\r\n    struct UserConfigurationMap {\r\n        /**\r\n         * @dev Bitmap of the users collaterals and borrows. It is divided in pairs of bits, one pair per asset.\r\n         * The first bit indicates if an asset is used as collateral by the user, the second whether an\r\n         * asset is borrowed by the user.\r\n         */\r\n        uint256 data;\r\n    }\r\n\r\n    struct EModeCategory {\r\n        // each eMode category has a custom ltv and liquidation threshold\r\n        uint16 ltv;\r\n        uint16 liquidationThreshold;\r\n        uint16 liquidationBonus;\r\n        // each eMode category may or may not have a custom oracle to override the individual assets price oracles\r\n        address priceSource;\r\n        string label;\r\n    }\r\n\r\n    enum InterestRateMode {\r\n        NONE,\r\n        STABLE,\r\n        VARIABLE\r\n    }\r\n\r\n    struct ReserveCache {\r\n        uint256 currScaledVariableDebt;\r\n        uint256 nextScaledVariableDebt;\r\n        uint256 currPrincipalStableDebt;\r\n        uint256 currAvgStableBorrowRate;\r\n        uint256 currTotalStableDebt;\r\n        uint256 nextAvgStableBorrowRate;\r\n        uint256 nextTotalStableDebt;\r\n        uint256 currLiquidityIndex;\r\n        uint256 nextLiquidityIndex;\r\n        uint256 currVariableBorrowIndex;\r\n        uint256 nextVariableBorrowIndex;\r\n        uint256 currLiquidityRate;\r\n        uint256 currVariableBorrowRate;\r\n        uint256 reserveFactor;\r\n        ReserveConfigurationMap reserveConfiguration;\r\n        address aTokenAddress;\r\n        address stableDebtTokenAddress;\r\n        address variableDebtTokenAddress;\r\n        uint40 reserveLastUpdateTimestamp;\r\n        uint40 stableDebtLastUpdateTimestamp;\r\n    }\r\n\r\n    struct ExecuteLiquidationCallParams {\r\n        uint256 reservesCount;\r\n        uint256 debtToCover;\r\n        address collateralAsset;\r\n        address debtAsset;\r\n        address user;\r\n        bool receiveAToken;\r\n        address priceOracle;\r\n        uint8 userEModeCategory;\r\n        address priceOracleSentinel;\r\n    }\r\n\r\n    struct ExecuteSupplyParams {\r\n        address asset;\r\n        uint256 amount;\r\n        address onBehalfOf;\r\n        uint16 referralCode;\r\n    }\r\n\r\n    struct ExecuteBorrowParams {\r\n        address asset;\r\n        address user;\r\n        address onBehalfOf;\r\n        uint256 amount;\r\n        InterestRateMode interestRateMode;\r\n        uint16 referralCode;\r\n        bool releaseUnderlying;\r\n        uint256 maxStableRateBorrowSizePercent;\r\n        uint256 reservesCount;\r\n        address oracle;\r\n        uint8 userEModeCategory;\r\n        address priceOracleSentinel;\r\n    }\r\n\r\n    struct ExecuteRepayParams {\r\n        address asset;\r\n        uint256 amount;\r\n        InterestRateMode interestRateMode;\r\n        address onBehalfOf;\r\n        bool useATokens;\r\n    }\r\n\r\n    struct ExecuteWithdrawParams {\r\n        address asset;\r\n        uint256 amount;\r\n        address to;\r\n        uint256 reservesCount;\r\n        address oracle;\r\n        uint8 userEModeCategory;\r\n    }\r\n\r\n    struct ExecuteSetUserEModeParams {\r\n        uint256 reservesCount;\r\n        address oracle;\r\n        uint8 categoryId;\r\n    }\r\n\r\n    struct FinalizeTransferParams {\r\n        address asset;\r\n        address from;\r\n        address to;\r\n        uint256 amount;\r\n        uint256 balanceFromBefore;\r\n        uint256 balanceToBefore;\r\n        uint256 reservesCount;\r\n        address oracle;\r\n        uint8 fromEModeCategory;\r\n    }\r\n\r\n    struct FlashloanParams {\r\n        address receiverAddress;\r\n        address[] assets;\r\n        uint256[] amounts;\r\n        uint256[] interestRateModes;\r\n        address onBehalfOf;\r\n        bytes params;\r\n        uint16 referralCode;\r\n        uint256 flashLoanPremiumToProtocol;\r\n        uint256 flashLoanPremiumTotal;\r\n        uint256 maxStableRateBorrowSizePercent;\r\n        uint256 reservesCount;\r\n        address addressesProvider;\r\n        uint8 userEModeCategory;\r\n        bool isAuthorizedFlashBorrower;\r\n    }\r\n\r\n    struct FlashloanSimpleParams {\r\n        address receiverAddress;\r\n        address asset;\r\n        uint256 amount;\r\n        bytes params;\r\n        uint16 referralCode;\r\n        uint256 flashLoanPremiumToProtocol;\r\n        uint256 flashLoanPremiumTotal;\r\n    }\r\n\r\n    struct FlashLoanRepaymentParams {\r\n        uint256 amount;\r\n        uint256 totalPremium;\r\n        uint256 flashLoanPremiumToProtocol;\r\n        address asset;\r\n        address receiverAddress;\r\n        uint16 referralCode;\r\n    }\r\n\r\n    struct CalculateUserAccountDataParams {\r\n        UserConfigurationMap userConfig;\r\n        uint256 reservesCount;\r\n        address user;\r\n        address oracle;\r\n        uint8 userEModeCategory;\r\n    }\r\n\r\n    struct ValidateBorrowParams {\r\n        ReserveCache reserveCache;\r\n        UserConfigurationMap userConfig;\r\n        address asset;\r\n        address userAddress;\r\n        uint256 amount;\r\n        InterestRateMode interestRateMode;\r\n        uint256 maxStableLoanPercent;\r\n        uint256 reservesCount;\r\n        address oracle;\r\n        uint8 userEModeCategory;\r\n        address priceOracleSentinel;\r\n        bool isolationModeActive;\r\n        address isolationModeCollateralAddress;\r\n        uint256 isolationModeDebtCeiling;\r\n    }\r\n\r\n    struct ValidateLiquidationCallParams {\r\n        ReserveCache debtReserveCache;\r\n        uint256 totalDebt;\r\n        uint256 healthFactor;\r\n        address priceOracleSentinel;\r\n    }\r\n\r\n    struct CalculateInterestRatesParams {\r\n        uint256 unbacked;\r\n        uint256 liquidityAdded;\r\n        uint256 liquidityTaken;\r\n        uint256 totalStableDebt;\r\n        uint256 totalVariableDebt;\r\n        uint256 averageStableBorrowRate;\r\n        uint256 reserveFactor;\r\n        address reserve;\r\n        address aToken;\r\n    }\r\n\r\n    struct InitReserveParams {\r\n        address asset;\r\n        address aTokenAddress;\r\n        address stableDebtAddress;\r\n        address variableDebtAddress;\r\n        address interestRateStrategyAddress;\r\n        uint16 reservesCount;\r\n        uint16 maxNumberReserves;\r\n    }\r\n}\r\n"
    },
    "@chainlink/contracts/src/v0.8/mocks/VRFCoordinatorV2Mock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// A mock for testing code that relies on VRFCoordinatorV2.\npragma solidity ^0.8.4;\n\nimport \"../interfaces/LinkTokenInterface.sol\";\nimport \"../interfaces/VRFCoordinatorV2Interface.sol\";\nimport \"../VRFConsumerBaseV2.sol\";\n\ncontract VRFCoordinatorV2Mock is VRFCoordinatorV2Interface {\n  uint96 public immutable BASE_FEE;\n  uint96 public immutable GAS_PRICE_LINK;\n  uint16 public immutable MAX_CONSUMERS = 100;\n\n  error InvalidSubscription();\n  error InsufficientBalance();\n  error MustBeSubOwner(address owner);\n  error TooManyConsumers();\n  error InvalidConsumer();\n  error InvalidRandomWords();\n\n  event RandomWordsRequested(\n    bytes32 indexed keyHash,\n    uint256 requestId,\n    uint256 preSeed,\n    uint64 indexed subId,\n    uint16 minimumRequestConfirmations,\n    uint32 callbackGasLimit,\n    uint32 numWords,\n    address indexed sender\n  );\n  event RandomWordsFulfilled(uint256 indexed requestId, uint256 outputSeed, uint96 payment, bool success);\n  event SubscriptionCreated(uint64 indexed subId, address owner);\n  event SubscriptionFunded(uint64 indexed subId, uint256 oldBalance, uint256 newBalance);\n  event SubscriptionCanceled(uint64 indexed subId, address to, uint256 amount);\n  event ConsumerAdded(uint64 indexed subId, address consumer);\n  event ConsumerRemoved(uint64 indexed subId, address consumer);\n\n  uint64 s_currentSubId;\n  uint256 s_nextRequestId = 1;\n  uint256 s_nextPreSeed = 100;\n  struct Subscription {\n    address owner;\n    uint96 balance;\n  }\n  mapping(uint64 => Subscription) s_subscriptions; /* subId */ /* subscription */\n  mapping(uint64 => address[]) s_consumers; /* subId */ /* consumers */\n\n  struct Request {\n    uint64 subId;\n    uint32 callbackGasLimit;\n    uint32 numWords;\n  }\n  mapping(uint256 => Request) s_requests; /* requestId */ /* request */\n\n  constructor(uint96 _baseFee, uint96 _gasPriceLink) {\n    BASE_FEE = _baseFee;\n    GAS_PRICE_LINK = _gasPriceLink;\n  }\n\n  function consumerIsAdded(uint64 _subId, address _consumer) public view returns (bool) {\n    address[] memory consumers = s_consumers[_subId];\n    for (uint256 i = 0; i < consumers.length; i++) {\n      if (consumers[i] == _consumer) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  modifier onlyValidConsumer(uint64 _subId, address _consumer) {\n    if (!consumerIsAdded(_subId, _consumer)) {\n      revert InvalidConsumer();\n    }\n    _;\n  }\n\n  /**\n   * @notice fulfillRandomWords fulfills the given request, sending the random words to the supplied\n   * @notice consumer.\n   *\n   * @dev This mock uses a simplified formula for calculating payment amount and gas usage, and does\n   * @dev not account for all edge cases handled in the real VRF coordinator. When making requests\n   * @dev against the real coordinator a small amount of additional LINK is required.\n   *\n   * @param _requestId the request to fulfill\n   * @param _consumer the VRF randomness consumer to send the result to\n   */\n  function fulfillRandomWords(uint256 _requestId, address _consumer) external {\n    fulfillRandomWordsWithOverride(_requestId, _consumer, new uint256[](0));\n  }\n\n  /**\n   * @notice fulfillRandomWordsWithOverride allows the user to pass in their own random words.\n   *\n   * @param _requestId the request to fulfill\n   * @param _consumer the VRF randomness consumer to send the result to\n   * @param _words user-provided random words\n   */\n  function fulfillRandomWordsWithOverride(\n    uint256 _requestId,\n    address _consumer,\n    uint256[] memory _words\n  ) public {\n    uint256 startGas = gasleft();\n    if (s_requests[_requestId].subId == 0) {\n      revert(\"nonexistent request\");\n    }\n    Request memory req = s_requests[_requestId];\n\n    if (_words.length == 0) {\n      _words = new uint256[](req.numWords);\n      for (uint256 i = 0; i < req.numWords; i++) {\n        _words[i] = uint256(keccak256(abi.encode(_requestId, i)));\n      }\n    } else if (_words.length != req.numWords) {\n      revert InvalidRandomWords();\n    }\n\n    VRFConsumerBaseV2 v;\n    bytes memory callReq = abi.encodeWithSelector(v.rawFulfillRandomWords.selector, _requestId, _words);\n    (bool success, ) = _consumer.call{gas: req.callbackGasLimit}(callReq);\n\n    uint96 payment = uint96(BASE_FEE + ((startGas - gasleft()) * GAS_PRICE_LINK));\n    if (s_subscriptions[req.subId].balance < payment) {\n      revert InsufficientBalance();\n    }\n    s_subscriptions[req.subId].balance -= payment;\n    delete (s_requests[_requestId]);\n    emit RandomWordsFulfilled(_requestId, _requestId, payment, success);\n  }\n\n  /**\n   * @notice fundSubscription allows funding a subscription with an arbitrary amount for testing.\n   *\n   * @param _subId the subscription to fund\n   * @param _amount the amount to fund\n   */\n  function fundSubscription(uint64 _subId, uint96 _amount) public {\n    if (s_subscriptions[_subId].owner == address(0)) {\n      revert InvalidSubscription();\n    }\n    uint96 oldBalance = s_subscriptions[_subId].balance;\n    s_subscriptions[_subId].balance += _amount;\n    emit SubscriptionFunded(_subId, oldBalance, oldBalance + _amount);\n  }\n\n  function requestRandomWords(\n    bytes32 _keyHash,\n    uint64 _subId,\n    uint16 _minimumRequestConfirmations,\n    uint32 _callbackGasLimit,\n    uint32 _numWords\n  ) external override onlyValidConsumer(_subId, msg.sender) returns (uint256) {\n    if (s_subscriptions[_subId].owner == address(0)) {\n      revert InvalidSubscription();\n    }\n\n    uint256 requestId = s_nextRequestId++;\n    uint256 preSeed = s_nextPreSeed++;\n\n    s_requests[requestId] = Request({subId: _subId, callbackGasLimit: _callbackGasLimit, numWords: _numWords});\n\n    emit RandomWordsRequested(\n      _keyHash,\n      requestId,\n      preSeed,\n      _subId,\n      _minimumRequestConfirmations,\n      _callbackGasLimit,\n      _numWords,\n      msg.sender\n    );\n    return requestId;\n  }\n\n  function createSubscription() external override returns (uint64 _subId) {\n    s_currentSubId++;\n    s_subscriptions[s_currentSubId] = Subscription({owner: msg.sender, balance: 0});\n    emit SubscriptionCreated(s_currentSubId, msg.sender);\n    return s_currentSubId;\n  }\n\n  function getSubscription(uint64 _subId)\n    external\n    view\n    override\n    returns (\n      uint96 balance,\n      uint64 reqCount,\n      address owner,\n      address[] memory consumers\n    )\n  {\n    if (s_subscriptions[_subId].owner == address(0)) {\n      revert InvalidSubscription();\n    }\n    return (s_subscriptions[_subId].balance, 0, s_subscriptions[_subId].owner, s_consumers[_subId]);\n  }\n\n  function cancelSubscription(uint64 _subId, address _to) external override onlySubOwner(_subId) {\n    emit SubscriptionCanceled(_subId, _to, s_subscriptions[_subId].balance);\n    delete (s_subscriptions[_subId]);\n  }\n\n  modifier onlySubOwner(uint64 _subId) {\n    address owner = s_subscriptions[_subId].owner;\n    if (owner == address(0)) {\n      revert InvalidSubscription();\n    }\n    if (msg.sender != owner) {\n      revert MustBeSubOwner(owner);\n    }\n    _;\n  }\n\n  function getRequestConfig()\n    external\n    pure\n    override\n    returns (\n      uint16,\n      uint32,\n      bytes32[] memory\n    )\n  {\n    return (3, 2000000, new bytes32[](0));\n  }\n\n  function addConsumer(uint64 _subId, address _consumer) external override onlySubOwner(_subId) {\n    if (s_consumers[_subId].length == MAX_CONSUMERS) {\n      revert TooManyConsumers();\n    }\n\n    if (consumerIsAdded(_subId, _consumer)) {\n      return;\n    }\n\n    s_consumers[_subId].push(_consumer);\n    emit ConsumerAdded(_subId, _consumer);\n  }\n\n  function removeConsumer(uint64 _subId, address _consumer)\n    external\n    override\n    onlySubOwner(_subId)\n    onlyValidConsumer(_subId, _consumer)\n  {\n    address[] storage consumers = s_consumers[_subId];\n    for (uint256 i = 0; i < consumers.length; i++) {\n      if (consumers[i] == _consumer) {\n        address last = consumers[consumers.length - 1];\n        consumers[i] = last;\n        consumers.pop();\n        break;\n      }\n    }\n\n    emit ConsumerRemoved(_subId, _consumer);\n  }\n\n  function getConfig()\n    external\n    view\n    returns (\n      uint16 minimumRequestConfirmations,\n      uint32 maxGasLimit,\n      uint32 stalenessSeconds,\n      uint32 gasAfterPaymentCalculation\n    )\n  {\n    return (4, 2_500_000, 2_700, 33285);\n  }\n\n  function getFeeConfig()\n    external\n    view\n    returns (\n      uint32 fulfillmentFlatFeeLinkPPMTier1,\n      uint32 fulfillmentFlatFeeLinkPPMTier2,\n      uint32 fulfillmentFlatFeeLinkPPMTier3,\n      uint32 fulfillmentFlatFeeLinkPPMTier4,\n      uint32 fulfillmentFlatFeeLinkPPMTier5,\n      uint24 reqsForTier2,\n      uint24 reqsForTier3,\n      uint24 reqsForTier4,\n      uint24 reqsForTier5\n    )\n  {\n    return (\n      100000, // 0.1 LINK\n      100000, // 0.1 LINK\n      100000, // 0.1 LINK\n      100000, // 0.1 LINK\n      100000, // 0.1 LINK\n      0,\n      0,\n      0,\n      0\n    );\n  }\n\n  function getFallbackWeiPerUnitLink() external view returns (int256) {\n    return 4000000000000000; // 0.004 Ether\n  }\n\n  function requestSubscriptionOwnerTransfer(uint64 _subId, address _newOwner) external pure override {\n    revert(\"not implemented\");\n  }\n\n  function acceptSubscriptionOwnerTransfer(uint64 _subId) external pure override {\n    revert(\"not implemented\");\n  }\n\n  function pendingRequestExists(uint64 subId) public view override returns (bool) {\n    revert(\"not implemented\");\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/LinkTokenInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface LinkTokenInterface {\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n  function approve(address spender, uint256 value) external returns (bool success);\n\n  function balanceOf(address owner) external view returns (uint256 balance);\n\n  function decimals() external view returns (uint8 decimalPlaces);\n\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\n\n  function increaseApproval(address spender, uint256 subtractedValue) external;\n\n  function name() external view returns (string memory tokenName);\n\n  function symbol() external view returns (string memory tokenSymbol);\n\n  function totalSupply() external view returns (uint256 totalTokensIssued);\n\n  function transfer(address to, uint256 value) external returns (bool success);\n\n  function transferAndCall(\n    address to,\n    uint256 value,\n    bytes calldata data\n  ) external returns (bool success);\n\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  ) external returns (bool success);\n}\n"
    },
    "contracts/test/VRFCoordinatorV2Mock.sol": {
      "content": "// A mock for testing code that relies on VRFCoordinatorV2.\r\n\r\nimport \"@chainlink/contracts/src/v0.8/mocks/VRFCoordinatorV2Mock.sol\";\r\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./AggregatorInterface.sol\";\nimport \"./AggregatorV3Interface.sol\";\n\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface {}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorInterface {\n  function latestAnswer() external view returns (int256);\n\n  function latestTimestamp() external view returns (uint256);\n\n  function latestRound() external view returns (uint256);\n\n  function getAnswer(uint256 roundId) external view returns (int256);\n\n  function getTimestamp(uint256 roundId) external view returns (uint256);\n\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\n\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\n}\n"
    },
    "contracts/test/MockV3Aggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol\";\r\n\r\n/**\r\n * @title MockV3Aggregator\r\n * @notice Based on the FluxAggregator contract\r\n * @notice Use this contract when you need to test\r\n * other contract's ability to read data from an\r\n * aggregator contract, but how the aggregator got\r\n * its answer is unimportant\r\n */\r\ncontract MockV3Aggregator is AggregatorV2V3Interface {\r\n    uint256 public constant override version = 0;\r\n\r\n    uint8 public override decimals;\r\n    int256 public override latestAnswer;\r\n    uint256 public override latestTimestamp;\r\n    uint256 public override latestRound;\r\n\r\n    mapping(uint256 => int256) public override getAnswer;\r\n    mapping(uint256 => uint256) public override getTimestamp;\r\n    mapping(uint256 => uint256) private getStartedAt;\r\n\r\n    constructor(uint8 _decimals, int256 _initialAnswer) {\r\n        decimals = _decimals;\r\n        updateAnswer(_initialAnswer);\r\n    }\r\n\r\n    function updateAnswer(int256 _answer) public {\r\n        latestAnswer = _answer;\r\n        latestTimestamp = block.timestamp;\r\n        latestRound++;\r\n        getAnswer[latestRound] = _answer;\r\n        getTimestamp[latestRound] = block.timestamp;\r\n        getStartedAt[latestRound] = block.timestamp;\r\n    }\r\n\r\n    function updateRoundData(\r\n        uint80 _roundId,\r\n        int256 _answer,\r\n        uint256 _timestamp,\r\n        uint256 _startedAt\r\n    ) public {\r\n        latestRound = _roundId;\r\n        latestAnswer = _answer;\r\n        latestTimestamp = _timestamp;\r\n        getAnswer[latestRound] = _answer;\r\n        getTimestamp[latestRound] = _timestamp;\r\n        getStartedAt[latestRound] = _startedAt;\r\n    }\r\n\r\n    function getRoundData(uint80 _roundId)\r\n        external\r\n        view\r\n        override\r\n        returns (\r\n            uint80 roundId,\r\n            int256 answer,\r\n            uint256 startedAt,\r\n            uint256 updatedAt,\r\n            uint80 answeredInRound\r\n        )\r\n    {\r\n        return (\r\n            _roundId,\r\n            getAnswer[_roundId],\r\n            getStartedAt[_roundId],\r\n            getTimestamp[_roundId],\r\n            _roundId\r\n        );\r\n    }\r\n\r\n    function latestRoundData()\r\n        external\r\n        view\r\n        override\r\n        returns (\r\n            uint80 roundId,\r\n            int256 answer,\r\n            uint256 startedAt,\r\n            uint256 updatedAt,\r\n            uint80 answeredInRound\r\n        )\r\n    {\r\n        return (\r\n            uint80(latestRound),\r\n            getAnswer[latestRound],\r\n            getStartedAt[latestRound],\r\n            getTimestamp[latestRound],\r\n            uint80(latestRound)\r\n        );\r\n    }\r\n\r\n    function description() external pure override returns (string memory) {\r\n        return \"v0.8/tests/MockV3Aggregator.sol\";\r\n    }\r\n}\r\n\r\n// MockOracle\r\n// Function signatures, event signatures, log topics\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}